use crate::common::harness::EditorTestHarness;
use crossterm::event::{KeyCode, KeyModifiers};
use std::fs;

/// Test that the config editor command is registered by the plugin
#[test]
fn test_config_editor_command_registered() {
    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    // Copy the config_editor.ts plugin
    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    let plugin_dest = plugins_dir.join("config_editor.ts");
    fs::copy(&plugin_source, &plugin_dest).unwrap();

    // Copy the config-schema.json file (generated by build.rs)
    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    let schema_dest = plugins_dir.join("config-schema.json");
    fs::copy(&schema_source, &schema_dest).unwrap();

    // Create harness with the project directory
    let mut harness =
        EditorTestHarness::with_config_and_working_dir(120, 30, Default::default(), project_root)
            .unwrap();

    // Initial render
    harness.render().unwrap();

    // Open command palette
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();

    // Type to find the Edit Configuration command
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();

    // The config editor command should be registered and visible in the palette
    harness.assert_screen_contains("Edit Configuration");
    harness.assert_screen_contains("config_editor");
}

/// Test that the config schema is properly generated
#[test]
fn test_config_schema_exists_and_valid() {
    let schema_path = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");

    // Check file exists
    assert!(schema_path.exists(), "config-schema.json should exist");

    // Read and parse
    let content = fs::read_to_string(&schema_path).unwrap();
    let schema: serde_json::Value = serde_json::from_str(&content).unwrap();

    // Verify basic schema structure
    assert!(schema.get("$schema").is_some(), "Should have $schema");
    assert!(schema.get("$defs").is_some(), "Should have $defs");
    assert!(schema.get("$ref").is_some(), "Should have root $ref");

    // Verify Config definition exists
    let defs = schema.get("$defs").unwrap();
    assert!(
        defs.get("Config").is_some(),
        "Should have Config definition"
    );
    assert!(
        defs.get("EditorConfig").is_some(),
        "Should have EditorConfig definition"
    );
    assert!(
        defs.get("FileExplorerConfig").is_some(),
        "Should have FileExplorerConfig definition"
    );

    // Verify Config has expected properties
    let config = defs.get("Config").unwrap();
    let properties = config.get("properties").unwrap();
    assert!(properties.get("theme").is_some(), "Config should have theme");
    assert!(
        properties.get("editor").is_some(),
        "Config should have editor"
    );
    assert!(
        properties.get("file_explorer").is_some(),
        "Config should have file_explorer"
    );
}

/// Test that the HighlighterPreference enum is correctly generated
#[test]
fn test_config_schema_enums() {
    let schema_path = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");

    let content = fs::read_to_string(&schema_path).unwrap();
    let schema: serde_json::Value = serde_json::from_str(&content).unwrap();

    let defs = schema.get("$defs").unwrap();

    // Check HighlighterPreference enum
    let highlighter_pref = defs.get("HighlighterPreference").unwrap();
    assert_eq!(
        highlighter_pref.get("type").unwrap().as_str().unwrap(),
        "string"
    );

    let enum_values = highlighter_pref.get("enum").unwrap().as_array().unwrap();
    assert!(enum_values.contains(&serde_json::json!("auto")));
    assert!(enum_values.contains(&serde_json::json!("tree-sitter")));
    assert!(enum_values.contains(&serde_json::json!("textmate")));
}
