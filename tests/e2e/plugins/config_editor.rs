use crate::common::harness::EditorTestHarness;
use crossterm::event::{KeyCode, KeyModifiers};
use std::fs;

/// Test that the config editor command is registered by the plugin
#[test]
fn test_config_editor_command_registered() {
    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    // Copy the config_editor.ts plugin
    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    let plugin_dest = plugins_dir.join("config_editor.ts");
    fs::copy(&plugin_source, &plugin_dest).unwrap();

    // Copy the config-schema.json file (generated by build.rs)
    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    let schema_dest = plugins_dir.join("config-schema.json");
    fs::copy(&schema_source, &schema_dest).unwrap();

    // Create harness with the project directory
    let mut harness =
        EditorTestHarness::with_config_and_working_dir(120, 30, Default::default(), project_root)
            .unwrap();

    // Initial render
    harness.render().unwrap();

    // Open command palette
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();

    // Type to find the Edit Configuration command
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();

    // The config editor command should be registered and visible in the palette
    harness.assert_screen_contains("Edit Configuration");
    harness.assert_screen_contains("config_editor");
}

/// Test that the config schema is properly generated
#[test]
fn test_config_schema_exists_and_valid() {
    let schema_path = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");

    // Check file exists
    assert!(schema_path.exists(), "config-schema.json should exist");

    // Read and parse
    let content = fs::read_to_string(&schema_path).unwrap();
    let schema: serde_json::Value = serde_json::from_str(&content).unwrap();

    // Verify basic schema structure
    assert!(schema.get("$schema").is_some(), "Should have $schema");
    assert!(schema.get("$defs").is_some(), "Should have $defs");

    // Verify $defs has expected type definitions
    let defs = schema.get("$defs").unwrap();
    assert!(
        defs.get("EditorConfig").is_some(),
        "Should have EditorConfig definition"
    );
    assert!(
        defs.get("FileExplorerConfig").is_some(),
        "Should have FileExplorerConfig definition"
    );

    // Config properties are now at root level (not via $ref)
    let properties = schema.get("properties").unwrap();
    assert!(
        properties.get("theme").is_some(),
        "Config should have theme"
    );
    assert!(
        properties.get("editor").is_some(),
        "Config should have editor"
    );
    assert!(
        properties.get("file_explorer").is_some(),
        "Config should have file_explorer"
    );
}

/// Test that the HighlighterPreference enum is correctly generated
#[test]
fn test_config_schema_enums() {
    let schema_path = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");

    let content = fs::read_to_string(&schema_path).unwrap();
    let schema: serde_json::Value = serde_json::from_str(&content).unwrap();

    let defs = schema.get("$defs").unwrap();

    // Check HighlighterPreference enum (uses oneOf with const values)
    let highlighter_pref = defs.get("HighlighterPreference").unwrap();
    let one_of = highlighter_pref.get("oneOf").unwrap().as_array().unwrap();

    // Extract const values from oneOf variants
    let const_values: Vec<&str> = one_of
        .iter()
        .filter_map(|v| v.get("const").and_then(|c| c.as_str()))
        .collect();

    assert!(const_values.contains(&"auto"));
    assert!(const_values.contains(&"tree-sitter"));
    assert!(const_values.contains(&"textmate"));
}

/// Test that config files saved by the editor can be deserialized
#[test]
fn test_config_file_deserialization() {
    use fresh::config::Config;

    // Create a sample config JSON that matches the schema
    let config_json = r#"{
        "theme": "high-contrast",
        "editor": {
            "tab_size": 4,
            "line_numbers": true,
            "relative_line_numbers": false,
            "line_wrap": false,
            "syntax_highlighting": true,
            "auto_indent": true
        },
        "file_explorer": {
            "show_hidden": false,
            "show_gitignored": false,
            "respect_gitignore": true,
            "width": 0.2
        },
        "active_keybinding_map": "default"
    }"#;

    // Verify it can be deserialized as a valid Config
    let result: Result<Config, _> = serde_json::from_str(config_json);
    assert!(
        result.is_ok(),
        "Config JSON should deserialize: {:?}",
        result.err()
    );

    let config = result.unwrap();
    assert_eq!(&*config.theme, "high-contrast");
    assert_eq!(config.editor.tab_size, 4);
    assert!(config.editor.line_numbers);
    assert!(!config.file_explorer.show_hidden);
}

/// Test that a minimal config file can be loaded
#[test]
fn test_minimal_config_deserialization() {
    use fresh::config::Config;

    // Minimal config - only required fields or fields without defaults
    let minimal_json = r#"{}"#;

    let result: Result<Config, _> = serde_json::from_str(minimal_json);
    assert!(
        result.is_ok(),
        "Empty config should deserialize with defaults: {:?}",
        result.err()
    );
}

/// Test that config with custom keybindings can be loaded
#[test]
fn test_config_with_keybindings() {
    use fresh::config::Config;

    let config_json = r#"{
        "keybindings": [
            {
                "key": "s",
                "modifiers": ["ctrl"],
                "action": "save"
            },
            {
                "keys": [
                    {"key": "x", "modifiers": ["ctrl"]},
                    {"key": "s", "modifiers": ["ctrl"]}
                ],
                "action": "save"
            }
        ]
    }"#;

    let result: Result<Config, _> = serde_json::from_str(config_json);
    assert!(
        result.is_ok(),
        "Config with keybindings should deserialize: {:?}",
        result.err()
    );

    let config = result.unwrap();
    assert_eq!(config.keybindings.len(), 2);
}

/// Test that cursor position is preserved after toggling a section
/// This test reproduces the bug where cursor jumps to top after expand/collapse
#[test]
fn test_config_editor_cursor_preserved_after_toggle() {
    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory and copy files
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    fs::copy(&plugin_source, plugins_dir.join("config_editor.ts")).unwrap();

    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    fs::copy(&schema_source, plugins_dir.join("config-schema.json")).unwrap();

    // Create a config file with nested sections
    let config_content = r#"{"theme": "test-theme", "editor": {"tab_size": 4}}"#;
    fs::write(project_root.join("config.json"), config_content).unwrap();

    // Create harness
    let mut harness =
        EditorTestHarness::with_config_and_working_dir(120, 40, Default::default(), project_root)
            .unwrap();

    harness.render().unwrap();

    // Open command palette and run Edit Configuration
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();

    // Process async operations to let the config editor load
    for _ in 0..30 {
        harness.process_async_and_render().unwrap();
    }

    // Move cursor down to find a section (e.g., "editor" section)
    // The editor should show sections like: theme, editor, file_explorer, etc.
    // Navigate down to find a section
    for _ in 0..5 {
        harness.send_key(KeyCode::Down, KeyModifiers::NONE).unwrap();
        harness.render().unwrap();
    }

    // Record cursor line before toggle
    let _screen_before = harness.screen_to_string();

    // Press Tab to toggle the section (expand/collapse)
    harness.send_key(KeyCode::Tab, KeyModifiers::NONE).unwrap();

    // Process any async operations
    for _ in 0..5 {
        harness.process_async_and_render().unwrap();
    }

    let screen_after = harness.screen_to_string();

    // The cursor should NOT jump back to the top of the buffer
    // We verify this by checking that the content changed (section toggled)
    // but the view didn't reset to show only the header at top

    // If cursor jumped to top, the first visible content line would be the header
    // If cursor stayed, we should still see content from the middle of the buffer

    // This is a basic check - the toggle should work without errors
    // The main thing we're testing is that the plugin doesn't crash with TextEncoder error
    assert!(
        screen_after.contains("Configuration") || screen_after.contains("Config"),
        "Config editor should still be visible after toggle"
    );

    // Check that no error messages appeared (e.g., TextEncoder not defined)
    assert!(
        !screen_after.contains("TextEncoder"),
        "Should not see TextEncoder error on screen"
    );
}

/// Test that the lsp section shows default entries even when user config is empty
/// This tests the getConfig/getUserConfig APIs - without them the lsp section
/// would appear empty because the user's config file has no lsp entries.
#[test]
fn test_config_editor_shows_lsp_defaults() {
    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory and copy files
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    fs::copy(&plugin_source, plugins_dir.join("config_editor.ts")).unwrap();

    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    fs::copy(&schema_source, plugins_dir.join("config-schema.json")).unwrap();

    // Create an EMPTY config file - no lsp entries
    // The bug was: without getConfig(), the editor would show nothing in lsp section
    // because it only read the sparse user config file
    let config_content = r#"{}"#;
    fs::write(project_root.join("config.json"), config_content).unwrap();

    // Create harness
    let mut harness =
        EditorTestHarness::with_config_and_working_dir(120, 50, Default::default(), project_root)
            .unwrap();

    harness.render().unwrap();

    // Open command palette and run Edit Configuration
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();

    // Process async operations to let the config editor load
    for _ in 0..30 {
        harness.process_async_and_render().unwrap();
    }

    // Navigate to find and expand the "lsp" section
    // First, let's find how many times we need to press down to reach "lsp"
    // The order in schema is roughly: active_keybinding_map, check_for_updates, editor, file_explorer, keybinding_maps, keybindings, languages, lsp, menu, theme
    // We need to navigate past the expanded sections (editor, file_explorer by default)

    // Press down multiple times to reach "lsp" section
    for _ in 0..30 {
        harness.send_key(KeyCode::Down, KeyModifiers::NONE).unwrap();
        harness.render().unwrap();
    }

    // Now look for the lsp section header and expand it with Tab
    // Try pressing Tab to expand (works on section rows)
    harness.send_key(KeyCode::Tab, KeyModifiers::NONE).unwrap();
    for _ in 0..10 {
        harness.process_async_and_render().unwrap();
    }

    // Continue navigating and looking for lsp-related content
    for _ in 0..5 {
        harness.send_key(KeyCode::Down, KeyModifiers::NONE).unwrap();
        harness.render().unwrap();
    }

    let screen = harness.screen_to_string();

    // The lsp section should show default entries from Config::default_lsp_config()
    // At minimum, we should see "rust" since rust-analyzer is a default LSP server
    // If the old bug existed (reading only user config), we'd see "(no entries configured)"
    // or the section would be empty

    // Check that we see at least one of the default LSP server names
    let has_rust = screen.contains("rust");
    let has_python = screen.contains("python");
    let has_typescript = screen.contains("typescript");
    let has_javascript = screen.contains("javascript");
    let has_html = screen.contains("html");

    // We should see at least one default LSP entry
    let has_any_default_lsp =
        has_rust || has_python || has_typescript || has_javascript || has_html;

    // Also verify we DON'T see the "no entries" message that would appear with an empty section
    let has_no_entries_msg = screen.contains("no entries configured");

    assert!(
        has_any_default_lsp || !has_no_entries_msg,
        "LSP section should show default servers (rust, python, etc.) or at least not show 'no entries' message.\n\
         Found in screen:\n\
         - rust: {}\n\
         - python: {}\n\
         - typescript: {}\n\
         - javascript: {}\n\
         - html: {}\n\
         - 'no entries configured': {}\n\n\
         Screen content:\n{}",
        has_rust, has_python, has_typescript, has_javascript, has_html, has_no_entries_msg, screen
    );
}

/// Test that saving config only stores non-default values
/// When a user sets a value that matches the default, it should be stripped on save.
#[test]
fn test_config_editor_strips_default_values_on_save() {
    use fresh::config::Config;

    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory and copy files
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    fs::copy(&plugin_source, plugins_dir.join("config_editor.ts")).unwrap();

    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    fs::copy(&schema_source, plugins_dir.join("config-schema.json")).unwrap();

    // Get the default config to know what values are default
    let default_config = Config::default();
    let default_tab_size = default_config.editor.tab_size;

    // Create a config file with some values that match defaults and some that don't
    // The theme default is "high-contrast", tab_size default is 4
    let config_content = format!(
        r#"{{
            "theme": "custom-theme",
            "editor": {{
                "tab_size": {},
                "line_numbers": true
            }}
        }}"#,
        default_tab_size // This matches the default and should be stripped
    );
    let config_path = project_root.join("config.json");
    fs::write(&config_path, config_content).unwrap();

    // Create harness
    let mut harness =
        EditorTestHarness::with_config_and_working_dir(120, 40, Default::default(), project_root)
            .unwrap();

    harness.render().unwrap();

    // Open command palette and run Edit Configuration
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();

    // Process async operations to let the config editor load
    for _ in 0..30 {
        harness.process_async_and_render().unwrap();
    }

    // Save the config (press 's' which is bound to save in config-editor mode)
    harness
        .send_key(KeyCode::Char('s'), KeyModifiers::NONE)
        .unwrap();

    // Process async operations for save
    for _ in 0..20 {
        harness.process_async_and_render().unwrap();
    }

    // Read the saved config file
    let saved_content = fs::read_to_string(&config_path).unwrap();
    let saved_config: serde_json::Value = serde_json::from_str(&saved_content).unwrap();

    // Verify: "theme" should be kept (non-default value "custom-theme")
    assert!(
        saved_config.get("theme").is_some(),
        "theme should be present (non-default value): {}",
        saved_content
    );
    assert_eq!(
        saved_config.get("theme").and_then(|v| v.as_str()),
        Some("custom-theme"),
        "theme should be 'custom-theme'"
    );

    // Verify: tab_size should be stripped (matches default value)
    // Either the entire "editor" section is missing, or tab_size is not in it
    if let Some(editor) = saved_config.get("editor") {
        assert!(
            editor.get("tab_size").is_none(),
            "tab_size should be stripped (matches default {}): {}",
            default_tab_size,
            saved_content
        );
    }

    // Verify: line_numbers should also be stripped if it matches default (true)
    if let Some(editor) = saved_config.get("editor") {
        // line_numbers default is true, so it should be stripped
        if default_config.editor.line_numbers {
            assert!(
                editor.get("line_numbers").is_none(),
                "line_numbers should be stripped (matches default true): {}",
                saved_content
            );
        }
    }
}

/// Test that config editor opens and shows content (integration test)
#[test]
fn test_config_editor_opens_with_content() {
    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory and copy files
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    fs::copy(&plugin_source, plugins_dir.join("config_editor.ts")).unwrap();

    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    fs::copy(&schema_source, plugins_dir.join("config-schema.json")).unwrap();

    // Create a config file in the project
    let config_content = r#"{"theme": "test-theme", "editor": {"tab_size": 8}}"#;
    fs::write(project_root.join("config.json"), config_content).unwrap();

    // Create harness
    let mut harness =
        EditorTestHarness::with_config_and_working_dir(120, 40, Default::default(), project_root)
            .unwrap();

    harness.render().unwrap();

    // Open command palette and run Edit Configuration
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();

    // Process async operations multiple times
    for _ in 0..20 {
        harness.process_async_and_render().unwrap();
    }

    let screen = harness.screen_to_string();

    // The config editor should be loading - check status bar
    // Note: Due to async loading, the editor may still be loading
    // This test verifies the command was executed
    assert!(
        screen.contains("Config") || screen.contains("Loading"),
        "Should show config editor or loading state"
    );
}

/// Test that changing the theme in settings UI and saving applies the visual theme at runtime
/// This verifies that the actual rendered colors change, not just the theme name
#[test]
fn test_config_editor_theme_change_applies_visual_colors() {
    use ratatui::style::Color;
    use tracing_subscriber::EnvFilter;
    let _ = tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env().add_directive(tracing::Level::DEBUG.into()))
        .with_test_writer()
        .try_init();

    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory and copy files
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    fs::copy(&plugin_source, plugins_dir.join("config_editor.ts")).unwrap();

    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    fs::copy(&schema_source, plugins_dir.join("config-schema.json")).unwrap();

    // Create a config file with the initial theme "light" (NOT the default!)
    // Default theme is "high-contrast", so using "light" exposes if config loading works
    let config_content = r#"{"theme": "light"}"#;
    let config_path = project_root.join("config.json");
    fs::write(&config_path, config_content).unwrap();

    // Create harness - use with_working_dir to load config from file like production does
    let mut harness = EditorTestHarness::with_working_dir(120, 40, project_root).unwrap();

    harness.render().unwrap();

    // Verify initial theme is "light" from our config file
    assert_eq!(
        harness.editor().theme().name,
        "light",
        "Initial theme should be 'light' from config file"
    );

    // Get the initial background color from an editor cell
    // light theme has editor_bg = Color::Rgb(255, 255, 255) (white)
    let initial_bg = harness.get_cell_style(5, 5).map(|s| s.bg);
    eprintln!("Initial background color: {:?}", initial_bg);

    // Open config editor via command palette
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();

    // Wait for config editor to load (shows "Configuration" in screen)
    harness.wait_for_screen_contains("Configuration").unwrap();

    // Move down to the theme field (skip header, file path, blank, comment)
    for _ in 0..4 {
        harness.send_key(KeyCode::Down, KeyModifiers::NONE).unwrap();
        harness.render().unwrap();
    }

    // Press Enter to edit the theme field
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();
    // Wait for prompt to open
    harness.wait_for_prompt().unwrap();

    // Type "high-contrast" to change the theme (black background - very different from white)
    harness.type_text("high-contrast").unwrap();
    harness.render().unwrap();

    // Press Enter to confirm the value
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();
    // Wait for prompt to close
    harness.wait_for_prompt_closed().unwrap();

    // Press 's' to save
    harness
        .send_key(KeyCode::Char('s'), KeyModifiers::NONE)
        .unwrap();
    // Wait for save to complete (file should be modified)
    let config_path_clone = config_path.clone();
    harness
        .wait_until(move |_| {
            fs::read_to_string(&config_path_clone)
                .map(|s| s.contains("high-contrast"))
                .unwrap_or(false)
        })
        .unwrap();

    // Close config editor to see the main editor
    harness
        .send_key(KeyCode::Char('q'), KeyModifiers::NONE)
        .unwrap();
    // Wait for config editor to close by checking the [Save] button is gone
    // (this is specific to config editor, unlike "Configuration" which may appear elsewhere)
    harness
        .wait_until(|h| !h.screen_to_string().contains("[Save]"))
        .unwrap();

    // Re-render to get updated colors
    harness.render().unwrap();

    // Get the new background color
    // high-contrast theme has editor_bg = Color::Black
    let new_bg = harness.get_cell_style(5, 5).map(|s| s.bg);
    eprintln!("New background color after theme change: {:?}", new_bg);

    // The visual colors should have changed
    // light: Rgb(255, 255, 255) white background
    // high-contrast: Black background
    assert_ne!(
        initial_bg, new_bg,
        "Visual background color should change when theme changes.\n\
         Initial (light): {:?}\n\
         After (high-contrast): {:?}\n\
         These should be different colors!",
        initial_bg, new_bg
    );

    // Specifically verify we now have a high-contrast theme background (black)
    // Note: Black can be either Color::Black or Color::Rgb(0, 0, 0)
    let is_black = matches!(
        new_bg,
        Some(Some(Color::Black)) | Some(Some(Color::Rgb(0, 0, 0)))
    );
    assert!(
        is_black,
        "After changing to 'high-contrast' theme, background should be black.\n\
         Got: {:?}",
        new_bg
    );
}

/// Test that pressing 's' keybinding saves the config file
/// BUG: User reports pressing 's' to save doesn't work
#[test]
fn test_config_editor_s_key_saves_config() {
    // Create a temporary project directory
    let temp_dir = tempfile::TempDir::new().unwrap();
    let project_root = temp_dir.path().join("project_root");
    fs::create_dir(&project_root).unwrap();

    // Create plugins directory and copy files
    let plugins_dir = project_root.join("plugins");
    fs::create_dir(&plugins_dir).unwrap();

    let plugin_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config_editor.ts");
    fs::copy(&plugin_source, plugins_dir.join("config_editor.ts")).unwrap();

    let schema_source = std::env::current_dir()
        .unwrap()
        .join("plugins/config-schema.json");
    fs::copy(&schema_source, plugins_dir.join("config-schema.json")).unwrap();

    // Create a config file with initial theme "light" (NOT the default!)
    // This exposes the bug if config isn't being loaded from working directory
    let config_content = r#"{"theme": "light"}"#;
    let config_path = project_root.join("config.json");
    fs::write(&config_path, config_content).unwrap();

    // Get initial modification time
    let initial_modified = fs::metadata(&config_path).unwrap().modified().unwrap();

    // Create harness - use with_working_dir to load config from file like production does
    let mut harness = EditorTestHarness::with_working_dir(120, 40, project_root).unwrap();

    harness.render().unwrap();

    // Verify initial theme is "light" from our config file
    assert_eq!(
        harness.editor().theme().name,
        "light",
        "Initial theme should be 'light' from config file"
    );

    // Open config editor via command palette
    harness
        .send_key(KeyCode::Char('p'), KeyModifiers::CONTROL)
        .unwrap();
    harness.render().unwrap();
    harness.type_text("Edit Configuration").unwrap();
    harness.render().unwrap();
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();

    // Wait for config editor to load
    harness.wait_for_screen_contains("Configuration").unwrap();

    // Move down to the theme field
    for _ in 0..4 {
        harness.send_key(KeyCode::Down, KeyModifiers::NONE).unwrap();
        harness.render().unwrap();
    }

    // Press Enter to edit, type new value, confirm
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();
    harness.wait_for_prompt().unwrap();
    harness.type_text("dark").unwrap();
    harness.render().unwrap();
    harness
        .send_key(KeyCode::Enter, KeyModifiers::NONE)
        .unwrap();
    harness.wait_for_prompt_closed().unwrap();

    // Sleep briefly to ensure filesystem timestamp would be different
    std::thread::sleep(std::time::Duration::from_millis(100));

    // Press 's' to save (this is the keybinding being tested)
    harness
        .send_key(KeyCode::Char('s'), KeyModifiers::NONE)
        .unwrap();

    // Wait for save to complete (file should contain "dark")
    let config_path_clone = config_path.clone();
    harness
        .wait_until(move |_| {
            fs::read_to_string(&config_path_clone)
                .map(|s| s.contains("dark"))
                .unwrap_or(false)
        })
        .unwrap();

    // Verify the file was modified
    let new_modified = fs::metadata(&config_path).unwrap().modified().unwrap();
    assert!(
        new_modified > initial_modified,
        "Config file should be modified after pressing 's' to save.\n\
         Initial mtime: {:?}\n\
         New mtime: {:?}\n\
         BUG: The 's' keybinding to save doesn't work!",
        initial_modified,
        new_modified
    );

    // Verify the content changed
    let saved_content = fs::read_to_string(&config_path).unwrap();
    assert!(
        saved_content.contains("dark"),
        "Saved config should contain 'dark' theme after pressing 's'.\n\
         Got: {}",
        saved_content
    );
}
